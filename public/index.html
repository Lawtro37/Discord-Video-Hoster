<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Video Hoster</title>
    <style>
      body { font-family: system-ui, Arial; max-width:800px; margin:40px auto; padding:0 20px; }
      .drop { border:2px dashed #888; padding:40px; text-align:center; border-radius:8px; }
      .links { margin-top:20px; }
      input[type=file]{ display:block; margin:10px auto; }
      .note {
        background: rgba(255, 241, 118, 0.6); /* soft translucent yellow */
        border: 1px solid rgba(204, 170, 0, 0.4);
        padding: 10px 14px;
        border-radius: 8px;
        display: inline-block;
      }
    </style>
  </head>
  <body>
    <h1>Discord Video Hoster</h1>
    <div class="drop" id="drop">Drop a video here or select one</div>
  <input id="file" type="file" accept="video/*,.mkv" />
  <p class="note"><strong>note:</strong> links and files are cleared when the server restarts</p>
    <div style="margin-top:5px">
      <label for="label">Custom label (used for Markdown/HTML/embed): </label>
      <input id="label" type="text" placeholder="Watch this video" style="width:60%; margin-left:8px" />
    </div>
    <div class="links" id="links"></div>

    <script>
      const drop = document.getElementById('drop');
      const fileInput = document.getElementById('file');
      const links = document.getElementById('links');

      ['dragenter','dragover','dragleave','drop'].forEach(e=>{
        drop.addEventListener(e, ev=>ev.preventDefault());
      });
      drop.addEventListener('drop', ev=>{
        const f = ev.dataTransfer.files[0];
        if (f) upload(f);
      });
      fileInput.addEventListener('change', ev=>{
        const f = ev.target.files[0];
        if (f) upload(f);
      });

      function createProgressUI(){
        links.innerHTML = '';
        const pcont = document.createElement('div');
        pcont.style.marginTop = '8px';
        const bar = document.createElement('progress');
        bar.max = 100;
        bar.value = 0;
        bar.style.width = '100%';
        const pct = document.createElement('div');
        pct.textContent = '0%';
        pct.style.textAlign = 'right';
        pct.style.fontSize = '12px';
        pct.style.marginTop = '4px';
        pcont.appendChild(bar);
        pcont.appendChild(pct);
        links.appendChild(pcont);
        return { bar, pct };
      }

      function upload(file){
        const fd = new FormData();
        fd.append('file', file);
        const ui = createProgressUI();

        const xhr = new XMLHttpRequest();
        xhr.open('POST', '/upload');
        xhr.upload.onprogress = (ev) => {
          if (ev.lengthComputable) {
            const percent = Math.round((ev.loaded / ev.total) * 100);
            ui.bar.value = percent;
            ui.pct.textContent = percent + '%';
          }
        };
        xhr.onreadystatechange = () => {
          if (xhr.readyState === 4) {
            if (xhr.status >= 200 && xhr.status < 300) {
              try{
                const j = JSON.parse(xhr.responseText);
                  renderResults(j);
                  // if server returned converted=false or job may be running, poll transcode status
                  pollTranscode(j.id);
              }catch(e){
                links.textContent = 'Upload finished but response parse failed';
              }
            } else {
              links.textContent = 'Upload failed: ' + xhr.status + ' ' + xhr.statusText + '\n' + xhr.responseText;
            }
          }
        };
        xhr.onerror = () => { links.textContent = 'Upload failed (network error)'; };
        xhr.send(fd);
      }

      function makeFormats(url, label){
        const safeLabel = (label || '').trim() || 'Watch video';
        return {
          direct: url,
          markdown: `[${safeLabel}](${url})`,
          spoiler: `||${url}||`,
          html: `<a href="${url}">${safeLabel}</a>`,
          webhookJSON: JSON.stringify({embeds:[{title:safeLabel, url: url, description: "Uploaded via Video Hoster"}]}, null, 2)
        };
      }

      function renderResults(j){
        links.innerHTML = '';
        const videoP = document.createElement('p');
        const aVideo = document.createElement('a');
        aVideo.href = j.videoUrl;
        aVideo.target = '_blank';
        aVideo.textContent = j.videoUrl;
        videoP.appendChild(document.createTextNode('Video URL: '));
        videoP.appendChild(aVideo);
        links.appendChild(videoP);

        const shortP = document.createElement('p');
        const aShort = document.createElement('a');
        aShort.href = j.shortUrl;
        aShort.target = '_blank';
        aShort.textContent = j.shortUrl;
        shortP.appendChild(document.createTextNode('Short URL: '));
        shortP.appendChild(aShort);
        links.appendChild(shortP);

        const videoEl = document.createElement('video');
        videoEl.src = `/v/${j.id}`;
        videoEl.controls = true;
        videoEl.width = 480;
        links.appendChild(videoEl);

        const labelInput = document.getElementById('label');
        const formats = makeFormats(j.videoUrl, labelInput.value);

        const note = document.createElement('p');
        note.style.marginTop = '12px';
        note.innerHTML = '<strong>Copy a format:</strong> click a copy button next to the format you want. Note: Discord chat does not support custom clickable Markdown links ([text](url)) in normal messages — use a webhook/embed or a bot to show a clickable title. Spoiler (||url||) hides the link until clicked.';
        links.appendChild(note);

        const list = document.createElement('div');
        list.style.marginTop = '8px';

        function addRow(label, value){
          const row = document.createElement('div');
          row.style.marginBottom = '8px';
          const lbl = document.createElement('div');
          lbl.textContent = label;
          lbl.style.fontWeight = '600';
          const ta = document.createElement('textarea');
          ta.readOnly = true;
          ta.rows = 1;
          ta.style.width = '100%';
          ta.textContent = value;
          const btn = document.createElement('button');
          btn.textContent = 'Copy';
          btn.style.marginTop = '4px';
          btn.addEventListener('click', async ()=>{
            try{
              await navigator.clipboard.writeText(value);
              btn.textContent = 'Copied!';
              setTimeout(()=>btn.textContent = 'Copy', 1500);
            }catch(e){
              // fallback: select the textarea
              ta.select();
              document.execCommand('copy');
              btn.textContent = 'Copied!';
              setTimeout(()=>btn.textContent = 'Copy', 1500);
            }
          });
          row.appendChild(lbl);
          row.appendChild(ta);
          row.appendChild(btn);
          list.appendChild(row);
        }

        addRow('Direct URL', formats.direct);
        addRow('Markdown-style [label](url) (NOT clickable in Discord chat)', formats.markdown);
        addRow('Spoiler (hides until clicked)', formats.spoiler);
        addRow('HTML anchor (useful in embeds or other platforms)', formats.html);
        addRow('Discord webhook/embed JSON (paste into a webhook payload)', formats.webhookJSON);

        links.appendChild(list);

  // area for conversion progress
  const convDiv = document.createElement('div');
  convDiv.id = 'conv-status-' + j.id;
  convDiv.style.marginTop = '10px';
  links.appendChild(convDiv);

        // webhook UI
        const whDiv = document.createElement('div');
        whDiv.style.marginTop = '12px';
        const whLabel = document.createElement('label');
        whLabel.textContent = 'Discord Webhook URL (optional): ';
        const whInput = document.createElement('input');
        whInput.type = 'text';
        whInput.style.width = '70%';
        whInput.placeholder = 'https://discord.com/api/webhooks/....';
        const postBtn = document.createElement('button');
        postBtn.textContent = 'Post Embed to Webhook';
        postBtn.style.marginLeft = '8px';
        postBtn.addEventListener('click', async ()=>{
          const url = whInput.value.trim();
          if (!url) return alert('Paste a webhook URL first');
          postBtn.disabled = true;
          postBtn.textContent = 'Posting...';
          try{
            const resp = await fetch('/post-webhook', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ webhookUrl: url, id: j.id, label: labelInput.value })
            });
            const jj = await resp.json();
            if (resp.ok) {
              postBtn.textContent = 'Posted ✓';
            } else {
              postBtn.textContent = 'Failed';
              alert('Webhook error: ' + JSON.stringify(jj));
            }
          }catch(e){
            alert('Error: ' + e);
            postBtn.textContent = 'Failed';
          }
          setTimeout(()=>{ postBtn.disabled = false; postBtn.textContent = 'Post Embed to Webhook'; }, 1500);
        });
        whDiv.appendChild(whLabel);
        whDiv.appendChild(whInput);
        whDiv.appendChild(postBtn);
        links.appendChild(whDiv);

        // update formats when user changes label
        const labelInputEl = document.getElementById('label');
        labelInputEl.oninput = ()=>{
          const newFormats = makeFormats(j.videoUrl, labelInputEl.value);
          // update all textareas in order
          const tas = list.querySelectorAll('textarea');
          const vals = [newFormats.direct, newFormats.angle, newFormats.spoiler, newFormats.markdown, newFormats.html, newFormats.webhookJSON];
          tas.forEach((t,i)=> t.textContent = vals[i]);
        };
      }

      let transcodePoller = null;
      function pollTranscode(id){
        const convDiv = document.getElementById('conv-status-' + id);
        if (!convDiv) return;
        // clear any existing
        if (transcodePoller) clearInterval(transcodePoller);
        transcodePoller = setInterval(async ()=>{
          try{
            const r = await fetch('/transcode-status/' + id);
            const j = await r.json();
            if (j.status === 'none') { convDiv.textContent = ''; clearInterval(transcodePoller); transcodePoller = null; return; }
            if (j.status === 'queued' || j.status === 'running'){
              convDiv.innerHTML = `<div style="font-weight:600">Converting: ${j.progress || 0}%</div>`;
            } else if (j.status === 'done'){
              convDiv.innerHTML = `<div style="font-weight:600">Conversion finished</div>`;
              clearInterval(transcodePoller); transcodePoller = null;
              // reload the page's info (fetch updated data) — simply refresh the current results by hitting /v/:id as video src is same
            } else if (j.status === 'error'){
              convDiv.innerHTML = `<div style="color:crimson">Conversion error: ${j.message}</div>`;
              clearInterval(transcodePoller); transcodePoller = null;
            }
          }catch(e){
            convDiv.innerHTML = `<div style="color:crimson">Conversion status check failed</div>`;
            clearInterval(transcodePoller); transcodePoller = null;
          }
        }, 1500);
      }
    </script>
  </body>
</html>
